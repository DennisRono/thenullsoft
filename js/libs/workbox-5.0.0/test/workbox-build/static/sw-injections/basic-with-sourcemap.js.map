{"version":3,"file":"basic-with-sourcemap.js","sources":["../node_modules/workbox-core/_version.js","../node_modules/workbox-core/_private/logger.js","../node_modules/workbox-core/models/messages/messageGenerator.js","../node_modules/workbox-core/_private/WorkboxError.js","../node_modules/workbox-core/_private/assert.js","../node_modules/workbox-core/_private/cacheNames.js","../node_modules/workbox-core/_private/getFriendlyURL.js","../node_modules/workbox-core/models/quotaErrorCallbacks.js","../node_modules/workbox-core/utils/pluginUtils.js","../node_modules/workbox-core/_private/cacheWrapper.js","../node_modules/workbox-core/_private/executeQuotaErrorCallbacks.js","../node_modules/workbox-core/_private/fetchWrapper.js","../node_modules/workbox-strategies/_version.js","../node_modules/workbox-core/_private/canConstructResponseFromBodyStream.js","../node_modules/workbox-core/_private/DBWrapper.js","../node_modules/workbox-core/copyResponse.js","../node_modules/workbox-precaching/_version.js","../node_modules/workbox-precaching/utils/precachePlugins.js","../node_modules/workbox-precaching/utils/createCacheKey.js","../node_modules/workbox-precaching/PrecacheController.js","../node_modules/workbox-precaching/utils/getOrCreatePrecacheController.js","../node_modules/workbox-precaching/utils/getCacheKeyForURL.js","../node_modules/workbox-precaching/utils/generateURLVariations.js","../node_modules/workbox-precaching/utils/removeIgnoredSearchParams.js","../node_modules/workbox-precaching/addRoute.js","../node_modules/workbox-precaching/utils/addFetchListener.js","../node_modules/workbox-precaching/precache.js","../node_modules/workbox-range-requests/_version.js","../node_modules/workbox-range-requests/createPartialResponse.js","../node_modules/workbox-range-requests/utils/parseRangeHeader.js","../node_modules/workbox-range-requests/utils/calculateEffectiveBoundaries.js","../node_modules/workbox-routing/_version.js","../node_modules/workbox-routing/utils/constants.js","../node_modules/workbox-routing/utils/normalizeHandler.js","../node_modules/workbox-routing/Route.js","../node_modules/workbox-routing/RegExpRoute.js","../node_modules/workbox-routing/Router.js","../node_modules/workbox-routing/utils/getOrCreateDefaultRouter.js","../node_modules/workbox-routing/registerRoute.js","../src/js/constants.js","../src/js/getCachedMediaMetadata.js","../src/svelte/routes/Audio.svelte","../src/svelte/routes/Images.svelte","../src/svelte/routes/Videos.svelte","../src/js/service-worker.js","../node_modules/workbox-strategies/CacheOnly.js","../node_modules/workbox-range-requests/RangeRequestsPlugin.js","../node_modules/workbox-precaching/precacheAndRoute.js","../node_modules/workbox-core/skipWaiting.js","../node_modules/workbox-core/clientsClaim.js"],"sourcesContent":["// @ts-ignore\ntry {\n    self['workbox:core:5.0.0-beta.0'] && _();\n}\ncatch (e) { }\n","/*\n  Copyright 2019 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\nconst logger = (process.env.NODE_ENV === 'production' ? null : (() => {\n    let inGroup = false;\n    const methodToColorMap = {\n        debug: `#7f8c8d`,\n        log: `#2ecc71`,\n        warn: `#f39c12`,\n        error: `#c0392b`,\n        groupCollapsed: `#3498db`,\n        groupEnd: null,\n    };\n    const print = function (method, args) {\n        if (method === 'groupCollapsed') {\n            // Safari doesn't print all console.groupCollapsed() arguments:\n            // https://bugs.webkit.org/show_bug.cgi?id=182754\n            if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {\n                console[method](...args);\n                return;\n            }\n        }\n        const styles = [\n            `background: ${methodToColorMap[method]}`,\n            `border-radius: 0.5em`,\n            `color: white`,\n            `font-weight: bold`,\n            `padding: 2px 0.5em`,\n        ];\n        // When in a group, the workbox prefix is not displayed.\n        const logPrefix = inGroup ? [] : ['%cworkbox', styles.join(';')];\n        console[method](...logPrefix, ...args);\n        if (method === 'groupCollapsed') {\n            inGroup = true;\n        }\n        if (method === 'groupEnd') {\n            inGroup = false;\n        }\n    };\n    const api = {};\n    const loggerMethods = Object.keys(methodToColorMap);\n    for (const key of loggerMethods) {\n        const method = key;\n        api[method] = (...args) => {\n            print(method, args);\n        };\n    }\n    return api;\n})());\nexport { logger };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { messages } from './messages.js';\nimport '../../_version.js';\nconst fallback = (code, ...args) => {\n    let msg = code;\n    if (args.length > 0) {\n        msg += ` :: ${JSON.stringify(args)}`;\n    }\n    return msg;\n};\nconst generatorFunction = (code, details = {}) => {\n    const message = messages[code];\n    if (!message) {\n        throw new Error(`Unable to find message for code '${code}'.`);\n    }\n    return message(details);\n};\nexport const messageGenerator = (process.env.NODE_ENV === 'production') ?\n    fallback : generatorFunction;\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { messageGenerator } from '../models/messages/messageGenerator.js';\nimport '../_version.js';\n/**\n * Workbox errors should be thrown with this class.\n * This allows use to ensure the type easily in tests,\n * helps developers identify errors from workbox\n * easily and allows use to optimise error\n * messages correctly.\n *\n * @private\n */\nclass WorkboxError extends Error {\n    /**\n     *\n     * @param {string} errorCode The error code that\n     * identifies this particular error.\n     * @param {Object=} details Any relevant arguments\n     * that will help developers identify issues should\n     * be added as a key on the context object.\n     */\n    constructor(errorCode, details) {\n        let message = messageGenerator(errorCode, details);\n        super(message);\n        this.name = errorCode;\n        this.details = details;\n    }\n}\nexport { WorkboxError };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { WorkboxError } from '../_private/WorkboxError.js';\nimport '../_version.js';\n/*\n * This method returns true if the current context is a service worker.\n */\nconst isSWEnv = (moduleName) => {\n    if (!('ServiceWorkerGlobalScope' in self)) {\n        throw new WorkboxError('not-in-sw', { moduleName });\n    }\n};\n/*\n * This method throws if the supplied value is not an array.\n * The destructed values are required to produce a meaningful error for users.\n * The destructed and restructured object is so it's clear what is\n * needed.\n */\nconst isArray = (value, details) => {\n    if (!Array.isArray(value)) {\n        throw new WorkboxError('not-an-array', details);\n    }\n};\nconst hasMethod = (object, expectedMethod, details) => {\n    const type = typeof object[expectedMethod];\n    if (type !== 'function') {\n        details.expectedMethod = expectedMethod;\n        throw new WorkboxError('missing-a-method', details);\n    }\n};\nconst isType = (object, expectedType, details) => {\n    if (typeof object !== expectedType) {\n        details.expectedType = expectedType;\n        throw new WorkboxError('incorrect-type', details);\n    }\n};\nconst isInstance = (object, expectedClass, details) => {\n    if (!(object instanceof expectedClass)) {\n        details.expectedClass = expectedClass;\n        throw new WorkboxError('incorrect-class', details);\n    }\n};\nconst isOneOf = (value, validValues, details) => {\n    if (!validValues.includes(value)) {\n        details.validValueDescription =\n            `Valid values are ${JSON.stringify(validValues)}.`;\n        throw new WorkboxError('invalid-value', details);\n    }\n};\nconst isArrayOfClass = (value, expectedClass, details) => {\n    const error = new WorkboxError('not-array-of-class', details);\n    if (!Array.isArray(value)) {\n        throw error;\n    }\n    for (let item of value) {\n        if (!(item instanceof expectedClass)) {\n            throw error;\n        }\n    }\n};\nconst finalAssertExports = process.env.NODE_ENV === 'production' ? null : {\n    hasMethod,\n    isArray,\n    isInstance,\n    isOneOf,\n    isSWEnv,\n    isType,\n    isArrayOfClass,\n};\nexport { finalAssertExports as assert };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\nconst _cacheNameDetails = {\n    googleAnalytics: 'googleAnalytics',\n    precache: 'precache-v2',\n    prefix: 'workbox',\n    runtime: 'runtime',\n    suffix: registration.scope,\n};\nconst _createCacheName = (cacheName) => {\n    return [_cacheNameDetails.prefix, cacheName, _cacheNameDetails.suffix]\n        .filter((value) => value && value.length > 0)\n        .join('-');\n};\nconst eachCacheNameDetail = (fn) => {\n    for (const key of Object.keys(_cacheNameDetails)) {\n        fn(key);\n    }\n};\nexport const cacheNames = {\n    updateDetails: (details) => {\n        eachCacheNameDetail((key) => {\n            if (typeof details[key] === 'string') {\n                _cacheNameDetails[key] = details[key];\n            }\n        });\n    },\n    getGoogleAnalyticsName: (userCacheName) => {\n        return userCacheName || _createCacheName(_cacheNameDetails.googleAnalytics);\n    },\n    getPrecacheName: (userCacheName) => {\n        return userCacheName || _createCacheName(_cacheNameDetails.precache);\n    },\n    getPrefix: () => {\n        return _cacheNameDetails.prefix;\n    },\n    getRuntimeName: (userCacheName) => {\n        return userCacheName || _createCacheName(_cacheNameDetails.runtime);\n    },\n    getSuffix: () => {\n        return _cacheNameDetails.suffix;\n    },\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\nconst getFriendlyURL = (url) => {\n    const urlObj = new URL(String(url), location.href);\n    if (urlObj.origin === location.origin) {\n        return urlObj.pathname;\n    }\n    return urlObj.href;\n};\nexport { getFriendlyURL };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n// Callbacks to be executed whenever there's a quota error.\nconst quotaErrorCallbacks = new Set();\nexport { quotaErrorCallbacks };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\nexport const pluginUtils = {\n    filter: (plugins, callbackName) => {\n        return plugins.filter((plugin) => callbackName in plugin);\n    },\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { WorkboxError } from './WorkboxError.js';\nimport { assert } from './assert.js';\nimport { getFriendlyURL } from './getFriendlyURL.js';\nimport { logger } from './logger.js';\nimport { executeQuotaErrorCallbacks } from './executeQuotaErrorCallbacks.js';\nimport { pluginUtils } from '../utils/pluginUtils.js';\nimport '../_version.js';\n/**\n * Wrapper around cache.put().\n *\n * Will call `cacheDidUpdate` on plugins if the cache was updated, using\n * `matchOptions` when determining what the old entry is.\n *\n * @param {Object} options\n * @param {string} options.cacheName\n * @param {Request} options.request\n * @param {Response} options.response\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @param {Object} [options.matchOptions]\n *\n * @private\n * @memberof module:workbox-core\n */\nconst putWrapper = async ({ cacheName, request, response, event, plugins = [], matchOptions, }) => {\n    if (process.env.NODE_ENV !== 'production') {\n        if (request.method && request.method !== 'GET') {\n            throw new WorkboxError('attempt-to-cache-non-get-request', {\n                url: getFriendlyURL(request.url),\n                method: request.method,\n            });\n        }\n    }\n    const effectiveRequest = await _getEffectiveRequest({\n        plugins, request, mode: 'write'\n    });\n    if (!response) {\n        if (process.env.NODE_ENV !== 'production') {\n            logger.error(`Cannot cache non-existent response for ` +\n                `'${getFriendlyURL(effectiveRequest.url)}'.`);\n        }\n        throw new WorkboxError('cache-put-with-no-response', {\n            url: getFriendlyURL(effectiveRequest.url),\n        });\n    }\n    let responseToCache = await _isResponseSafeToCache({\n        event,\n        plugins,\n        response,\n        request: effectiveRequest,\n    });\n    if (!responseToCache) {\n        if (process.env.NODE_ENV !== 'production') {\n            logger.debug(`Response '${getFriendlyURL(effectiveRequest.url)}' will ` +\n                `not be cached.`, responseToCache);\n        }\n        return;\n    }\n    const cache = await caches.open(cacheName);\n    const updatePlugins = pluginUtils.filter(plugins, \"cacheDidUpdate\" /* CACHE_DID_UPDATE */);\n    let oldResponse = updatePlugins.length > 0 ?\n        await matchWrapper({ cacheName, matchOptions, request: effectiveRequest }) :\n        null;\n    if (process.env.NODE_ENV !== 'production') {\n        logger.debug(`Updating the '${cacheName}' cache with a new Response for ` +\n            `${getFriendlyURL(effectiveRequest.url)}.`);\n    }\n    try {\n        await cache.put(effectiveRequest, responseToCache);\n    }\n    catch (error) {\n        // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError\n        if (error.name === 'QuotaExceededError') {\n            await executeQuotaErrorCallbacks();\n        }\n        throw error;\n    }\n    for (let plugin of updatePlugins) {\n        await plugin[\"cacheDidUpdate\" /* CACHE_DID_UPDATE */].call(plugin, {\n            cacheName,\n            event,\n            oldResponse,\n            newResponse: responseToCache,\n            request: effectiveRequest,\n        });\n    }\n};\n/**\n * This is a wrapper around cache.match().\n *\n * @param {Object} options\n * @param {string} options.cacheName Name of the cache to match against.\n * @param {Request} options.request The Request that will be used to look up\n *     cache entries.\n * @param {Event} [options.event] The event that propted the action.\n * @param {Object} [options.matchOptions] Options passed to cache.match().\n * @param {Array<Object>} [options.plugins=[]] Array of plugins.\n * @return {Response} A cached response if available.\n *\n * @private\n * @memberof module:workbox-core\n */\nconst matchWrapper = async ({ cacheName, request, event, matchOptions, plugins = [], }) => {\n    const cache = await caches.open(cacheName);\n    const effectiveRequest = await _getEffectiveRequest({\n        plugins, request, mode: 'read'\n    });\n    let cachedResponse = await cache.match(effectiveRequest, matchOptions);\n    if (process.env.NODE_ENV !== 'production') {\n        if (cachedResponse) {\n            logger.debug(`Found a cached response in '${cacheName}'.`);\n        }\n        else {\n            logger.debug(`No cached response found in '${cacheName}'.`);\n        }\n    }\n    for (const plugin of plugins) {\n        if (\"cachedResponseWillBeUsed\" /* CACHED_RESPONSE_WILL_BE_USED */ in plugin) {\n            const pluginMethod = plugin[\"cachedResponseWillBeUsed\" /* CACHED_RESPONSE_WILL_BE_USED */];\n            cachedResponse = await pluginMethod.call(plugin, {\n                cacheName,\n                event,\n                matchOptions,\n                cachedResponse,\n                request: effectiveRequest,\n            });\n            if (process.env.NODE_ENV !== 'production') {\n                if (cachedResponse) {\n                    assert.isInstance(cachedResponse, Response, {\n                        moduleName: 'Plugin',\n                        funcName: \"cachedResponseWillBeUsed\" /* CACHED_RESPONSE_WILL_BE_USED */,\n                        isReturnValueProblem: true,\n                    });\n                }\n            }\n        }\n    }\n    return cachedResponse;\n};\n/**\n * This method will call cacheWillUpdate on the available plugins (or use\n * status === 200) to determine if the Response is safe and valid to cache.\n *\n * @param {Object} options\n * @param {Request} options.request\n * @param {Response} options.response\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Response>}\n *\n * @private\n * @memberof module:workbox-core\n */\nconst _isResponseSafeToCache = async ({ request, response, event, plugins = [], }) => {\n    let responseToCache = response;\n    let pluginsUsed = false;\n    for (let plugin of plugins) {\n        if (\"cacheWillUpdate\" /* CACHE_WILL_UPDATE */ in plugin) {\n            pluginsUsed = true;\n            const pluginMethod = plugin[\"cacheWillUpdate\" /* CACHE_WILL_UPDATE */];\n            responseToCache = await pluginMethod.call(plugin, {\n                request,\n                response: responseToCache,\n                event,\n            });\n            if (process.env.NODE_ENV !== 'production') {\n                if (responseToCache) {\n                    assert.isInstance(responseToCache, Response, {\n                        moduleName: 'Plugin',\n                        funcName: \"cacheWillUpdate\" /* CACHE_WILL_UPDATE */,\n                        isReturnValueProblem: true,\n                    });\n                }\n            }\n            if (!responseToCache) {\n                break;\n            }\n        }\n    }\n    if (!pluginsUsed) {\n        if (process.env.NODE_ENV !== 'production') {\n            if (responseToCache) {\n                if (responseToCache.status !== 200) {\n                    if (responseToCache.status === 0) {\n                        logger.warn(`The response for '${request.url}' is an opaque ` +\n                            `response. The caching strategy that you're using will not ` +\n                            `cache opaque responses by default.`);\n                    }\n                    else {\n                        logger.debug(`The response for '${request.url}' returned ` +\n                            `a status code of '${response.status}' and won't be cached as a ` +\n                            `result.`);\n                    }\n                }\n            }\n        }\n        responseToCache = responseToCache && responseToCache.status === 200 ?\n            responseToCache : undefined;\n    }\n    return responseToCache ? responseToCache : null;\n};\n/**\n * Checks the list of plugins for the cacheKeyWillBeUsed callback, and\n * executes any of those callbacks found in sequence. The final `Request` object\n * returned by the last plugin is treated as the cache key for cache reads\n * and/or writes.\n *\n * @param {Object} options\n * @param {Request} options.request\n * @param {string} options.mode\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Request>}\n *\n * @private\n * @memberof module:workbox-core\n */\nconst _getEffectiveRequest = async ({ request, mode, plugins = [], }) => {\n    const cacheKeyWillBeUsedPlugins = pluginUtils.filter(plugins, \"cacheKeyWillBeUsed\" /* CACHE_KEY_WILL_BE_USED */);\n    let effectiveRequest = request;\n    for (const plugin of cacheKeyWillBeUsedPlugins) {\n        effectiveRequest = await plugin[\"cacheKeyWillBeUsed\" /* CACHE_KEY_WILL_BE_USED */].call(plugin, { mode, request: effectiveRequest });\n        if (typeof effectiveRequest === 'string') {\n            effectiveRequest = new Request(effectiveRequest);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(effectiveRequest, Request, {\n                moduleName: 'Plugin',\n                funcName: \"cacheKeyWillBeUsed\" /* CACHE_KEY_WILL_BE_USED */,\n                isReturnValueProblem: true,\n            });\n        }\n    }\n    return effectiveRequest;\n};\nexport const cacheWrapper = {\n    put: putWrapper,\n    match: matchWrapper,\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { logger } from '../_private/logger.js';\nimport { quotaErrorCallbacks } from '../models/quotaErrorCallbacks.js';\nimport '../_version.js';\n/**\n * Runs all of the callback functions, one at a time sequentially, in the order\n * in which they were registered.\n *\n * @memberof workbox.core\n * @private\n */\nasync function executeQuotaErrorCallbacks() {\n    if (process.env.NODE_ENV !== 'production') {\n        logger.log(`About to run ${quotaErrorCallbacks.size} ` +\n            `callbacks to clean up caches.`);\n    }\n    for (const callback of quotaErrorCallbacks) {\n        await callback();\n        if (process.env.NODE_ENV !== 'production') {\n            logger.log(callback, 'is complete.');\n        }\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        logger.log('Finished running callbacks.');\n    }\n}\nexport { executeQuotaErrorCallbacks };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { WorkboxError } from './WorkboxError.js';\nimport { logger } from './logger.js';\nimport { assert } from './assert.js';\nimport { getFriendlyURL } from '../_private/getFriendlyURL.js';\nimport { pluginUtils } from '../utils/pluginUtils.js';\nimport '../_version.js';\n/**\n * Wrapper around the fetch API.\n *\n * Will call requestWillFetch on available plugins.\n *\n * @param {Object} options\n * @param {Request|string} options.request\n * @param {Object} [options.fetchOptions]\n * @param {Event} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Response>}\n *\n * @private\n * @memberof module:workbox-core\n */\nconst wrappedFetch = async ({ request, fetchOptions, event, plugins = [], }) => {\n    if (typeof request === 'string') {\n        request = new Request(request);\n    }\n    // We *should* be able to call `await event.preloadResponse` even if it's\n    // undefined, but for some reason, doing so leads to errors in our Node unit\n    // tests. To work around that, explicitly check preloadResponse's value first.\n    if (event instanceof FetchEvent && event.preloadResponse) {\n        const possiblePreloadResponse = await event.preloadResponse;\n        if (possiblePreloadResponse) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.log(`Using a preloaded navigation response for ` +\n                    `'${getFriendlyURL(request.url)}'`);\n            }\n            return possiblePreloadResponse;\n        }\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        assert.isInstance(request, Request, {\n            paramName: 'request',\n            expectedClass: Request,\n            moduleName: 'workbox-core',\n            className: 'fetchWrapper',\n            funcName: 'wrappedFetch',\n        });\n    }\n    const failedFetchPlugins = pluginUtils.filter(plugins, \"fetchDidFail\" /* FETCH_DID_FAIL */);\n    // If there is a fetchDidFail plugin, we need to save a clone of the\n    // original request before it's either modified by a requestWillFetch\n    // plugin or before the original request's body is consumed via fetch().\n    const originalRequest = failedFetchPlugins.length > 0 ?\n        request.clone() : null;\n    try {\n        for (let plugin of plugins) {\n            if (\"requestWillFetch\" /* REQUEST_WILL_FETCH */ in plugin) {\n                const pluginMethod = plugin[\"requestWillFetch\" /* REQUEST_WILL_FETCH */];\n                const requestClone = request.clone();\n                request = (await pluginMethod.call(plugin, {\n                    request: requestClone,\n                    event,\n                }));\n                if (process.env.NODE_ENV !== 'production') {\n                    if (request) {\n                        assert.isInstance(request, Request, {\n                            moduleName: 'Plugin',\n                            funcName: \"cachedResponseWillBeUsed\" /* CACHED_RESPONSE_WILL_BE_USED */,\n                            isReturnValueProblem: true,\n                        });\n                    }\n                }\n            }\n        }\n    }\n    catch (err) {\n        throw new WorkboxError('plugin-error-request-will-fetch', {\n            thrownError: err,\n        });\n    }\n    // The request can be altered by plugins with `requestWillFetch` making\n    // the original request (Most likely from a `fetch` event) to be different\n    // to the Request we make. Pass both to `fetchDidFail` to aid debugging.\n    let pluginFilteredRequest = request.clone();\n    try {\n        let fetchResponse;\n        // See https://github.com/GoogleChrome/workbox/issues/1796\n        if (request.mode === 'navigate') {\n            fetchResponse = await fetch(request);\n        }\n        else {\n            fetchResponse = await fetch(request, fetchOptions);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            logger.debug(`Network request for ` +\n                `'${getFriendlyURL(request.url)}' returned a response with ` +\n                `status '${fetchResponse.status}'.`);\n        }\n        for (const plugin of plugins) {\n            if (\"fetchDidSucceed\" /* FETCH_DID_SUCCEED */ in plugin) {\n                fetchResponse = await plugin[\"fetchDidSucceed\" /* FETCH_DID_SUCCEED */]\n                    .call(plugin, {\n                    event,\n                    request: pluginFilteredRequest,\n                    response: fetchResponse,\n                });\n                if (process.env.NODE_ENV !== 'production') {\n                    if (fetchResponse) {\n                        assert.isInstance(fetchResponse, Response, {\n                            moduleName: 'Plugin',\n                            funcName: \"fetchDidSucceed\" /* FETCH_DID_SUCCEED */,\n                            isReturnValueProblem: true,\n                        });\n                    }\n                }\n            }\n        }\n        return fetchResponse;\n    }\n    catch (error) {\n        if (process.env.NODE_ENV !== 'production') {\n            logger.error(`Network request for ` +\n                `'${getFriendlyURL(request.url)}' threw an error.`, error);\n        }\n        for (const plugin of failedFetchPlugins) {\n            await plugin[\"fetchDidFail\" /* FETCH_DID_FAIL */].call(plugin, {\n                error,\n                event,\n                originalRequest: originalRequest.clone(),\n                request: pluginFilteredRequest.clone(),\n            });\n        }\n        throw error;\n    }\n};\nconst fetchWrapper = {\n    fetch: wrappedFetch,\n};\nexport { fetchWrapper };\n","// @ts-ignore\ntry {\n    self['workbox:strategies:5.0.0-beta.0'] && _();\n}\ncatch (e) { }\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\nlet supportStatus;\n/**\n * A utility function that determines whether the current browser supports\n * constructing a new `Response` from a `response.body` stream.\n *\n * @return {boolean} `true`, if the current browser can successfully\n *     construct a `Response` from a `response.body` stream, `false` otherwise.\n *\n * @private\n */\nfunction canConstructResponseFromBodyStream() {\n    if (supportStatus === undefined) {\n        const testResponse = new Response('');\n        if ('body' in testResponse) {\n            try {\n                new Response(testResponse.body);\n                supportStatus = true;\n            }\n            catch (error) {\n                supportStatus = false;\n            }\n        }\n        supportStatus = false;\n    }\n    return supportStatus;\n}\nexport { canConstructResponseFromBodyStream };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * A class that wraps common IndexedDB functionality in a promise-based API.\n * It exposes all the underlying power and functionality of IndexedDB, but\n * wraps the most commonly used features in a way that's much simpler to use.\n *\n * @private\n */\nexport class DBWrapper {\n    /**\n     * @param {string} name\n     * @param {number} version\n     * @param {Object=} [callback]\n     * @param {!Function} [callbacks.onupgradeneeded]\n     * @param {!Function} [callbacks.onversionchange] Defaults to\n     *     DBWrapper.prototype._onversionchange when not specified.\n     * @private\n     */\n    constructor(name, version, { onupgradeneeded, onversionchange, } = {}) {\n        this._db = null;\n        this._name = name;\n        this._version = version;\n        this._onupgradeneeded = onupgradeneeded;\n        this._onversionchange = onversionchange || (() => this.close());\n    }\n    /**\n     * Returns the IDBDatabase instance (not normally needed).\n     * @return {IDBDatabase|undefined}\n     *\n     * @private\n     */\n    get db() {\n        return this._db;\n    }\n    /**\n     * Opens a connected to an IDBDatabase, invokes any onupgradedneeded\n     * callback, and added an onversionchange callback to the database.\n     *\n     * @return {IDBDatabase}\n     * @private\n     */\n    async open() {\n        if (this._db)\n            return;\n        this._db = await new Promise((resolve, reject) => {\n            // This flag is flipped to true if the timeout callback runs prior\n            // to the request failing or succeeding. Note: we use a timeout instead\n            // of an onblocked handler since there are cases where onblocked will\n            // never never run. A timeout better handles all possible scenarios:\n            // https://github.com/w3c/IndexedDB/issues/223\n            let openRequestTimedOut = false;\n            setTimeout(() => {\n                openRequestTimedOut = true;\n                reject(new Error('The open request was blocked and timed out'));\n            }, this.OPEN_TIMEOUT);\n            const openRequest = indexedDB.open(this._name, this._version);\n            openRequest.onerror = () => reject(openRequest.error);\n            openRequest.onupgradeneeded = (evt) => {\n                if (openRequestTimedOut) {\n                    openRequest.transaction.abort();\n                    openRequest.result.close();\n                }\n                else if (typeof this._onupgradeneeded === 'function') {\n                    this._onupgradeneeded(evt);\n                }\n            };\n            openRequest.onsuccess = () => {\n                const db = openRequest.result;\n                if (openRequestTimedOut) {\n                    db.close();\n                }\n                else {\n                    db.onversionchange = this._onversionchange.bind(this);\n                    resolve(db);\n                }\n            };\n        });\n        return this;\n    }\n    /**\n     * Polyfills the native `getKey()` method. Note, this is overridden at\n     * runtime if the browser supports the native method.\n     *\n     * @param {string} storeName\n     * @param {*} query\n     * @return {Array}\n     * @private\n     */\n    async getKey(storeName, query) {\n        return (await this.getAllKeys(storeName, query, 1))[0];\n    }\n    /**\n     * Polyfills the native `getAll()` method. Note, this is overridden at\n     * runtime if the browser supports the native method.\n     *\n     * @param {string} storeName\n     * @param {*} query\n     * @param {number} count\n     * @return {Array}\n     * @private\n     */\n    async getAll(storeName, query, count) {\n        return await this.getAllMatching(storeName, { query, count });\n    }\n    /**\n     * Polyfills the native `getAllKeys()` method. Note, this is overridden at\n     * runtime if the browser supports the native method.\n     *\n     * @param {string} storeName\n     * @param {*} query\n     * @param {number} count\n     * @return {Array}\n     * @private\n     */\n    async getAllKeys(storeName, query, count) {\n        const entries = await this.getAllMatching(storeName, { query, count, includeKeys: true });\n        return entries.map((entry) => entry.key);\n    }\n    /**\n     * Supports flexible lookup in an object store by specifying an index,\n     * query, direction, and count. This method returns an array of objects\n     * with the signature .\n     *\n     * @param {string} storeName\n     * @param {Object} [opts]\n     * @param {string} [opts.index] The index to use (if specified).\n     * @param {*} [opts.query]\n     * @param {IDBCursorDirection} [opts.direction]\n     * @param {number} [opts.count] The max number of results to return.\n     * @param {boolean} [opts.includeKeys] When true, the structure of the\n     *     returned objects is changed from an array of values to an array of\n     *     objects in the form {key, primaryKey, value}.\n     * @return {Array}\n     * @private\n     */\n    async getAllMatching(storeName, { index, query = null, // IE/Edge errors if query === `undefined`.\n    direction = 'next', count, includeKeys = false, } = {}) {\n        return await this.transaction([storeName], 'readonly', (txn, done) => {\n            const store = txn.objectStore(storeName);\n            const target = index ? store.index(index) : store;\n            const results = [];\n            const request = target.openCursor(query, direction);\n            request.onsuccess = () => {\n                const cursor = request.result;\n                if (cursor) {\n                    results.push(includeKeys ? cursor : cursor.value);\n                    if (count && results.length >= count) {\n                        done(results);\n                    }\n                    else {\n                        cursor.continue();\n                    }\n                }\n                else {\n                    done(results);\n                }\n            };\n        });\n    }\n    /**\n     * Accepts a list of stores, a transaction type, and a callback and\n     * performs a transaction. A promise is returned that resolves to whatever\n     * value the callback chooses. The callback holds all the transaction logic\n     * and is invoked with two arguments:\n     *   1. The IDBTransaction object\n     *   2. A `done` function, that's used to resolve the promise when\n     *      when the transaction is done, if passed a value, the promise is\n     *      resolved to that value.\n     *\n     * @param {Array<string>} storeNames An array of object store names\n     *     involved in the transaction.\n     * @param {string} type Can be `readonly` or `readwrite`.\n     * @param {!Function} callback\n     * @return {*} The result of the transaction ran by the callback.\n     * @private\n     */\n    async transaction(storeNames, type, callback) {\n        await this.open();\n        return await new Promise((resolve, reject) => {\n            const txn = this._db.transaction(storeNames, type);\n            txn.onabort = () => reject(txn.error);\n            txn.oncomplete = () => resolve();\n            callback(txn, (value) => resolve(value));\n        });\n    }\n    /**\n     * Delegates async to a native IDBObjectStore method.\n     *\n     * @param {string} method The method name.\n     * @param {string} storeName The object store name.\n     * @param {string} type Can be `readonly` or `readwrite`.\n     * @param {...*} args The list of args to pass to the native method.\n     * @return {*} The result of the transaction.\n     * @private\n     */\n    async _call(method, storeName, type, ...args) {\n        const callback = (txn, done) => {\n            const objStore = txn.objectStore(storeName);\n            const request = objStore[method].apply(objStore, args);\n            request.onsuccess = () => done(request.result);\n        };\n        return await this.transaction([storeName], type, callback);\n    }\n    /**\n     * Closes the connection opened by `DBWrapper.open()`. Generally this method\n     * doesn't need to be called since:\n     *   1. It's usually better to keep a connection open since opening\n     *      a new connection is somewhat slow.\n     *   2. Connections are automatically closed when the reference is\n     *      garbage collected.\n     * The primary use case for needing to close a connection is when another\n     * reference (typically in another tab) needs to upgrade it and would be\n     * blocked by the current, open connection.\n     *\n     * @private\n     */\n    close() {\n        if (this._db) {\n            this._db.close();\n            this._db = null;\n        }\n    }\n}\n// Exposed on the prototype to let users modify the default timeout on a\n// per-instance or global basis.\nDBWrapper.prototype.OPEN_TIMEOUT = 2000;\n// Wrap native IDBObjectStore methods according to their mode.\nconst methodsToWrap = {\n    readonly: ['get', 'count', 'getKey', 'getAll', 'getAllKeys'],\n    readwrite: ['add', 'put', 'clear', 'delete'],\n};\nfor (const [mode, methods] of Object.entries(methodsToWrap)) {\n    for (const method of methods) {\n        if (method in IDBObjectStore.prototype) {\n            // Don't use arrow functions here since we're outside of the class.\n            DBWrapper.prototype[method] =\n                async function (storeName, ...args) {\n                    return await this._call(method, storeName, mode, ...args);\n                };\n        }\n    }\n}\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { canConstructResponseFromBodyStream } from './_private/canConstructResponseFromBodyStream.js';\nimport './_version.js';\n/**\n * Allows developers to copy a response and modify its `headers`, `status`,\n * or `statusText` values (the values settable via a\n * [`ResponseInit`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Response/Response#Syntax}\n * object in the constructor).\n * To modify these values, pass a function as the second argument. That\n * function will be invoked with a single object with the response properties\n * `{headers, status, statusText}`. The return value of this function will\n * be used as the `ResponseInit` for the new `Response`. To change the values\n * either modify the passed parameter(s) and return it, or return a totally\n * new object.\n *\n * @param {Response} response\n * @param {Function} modifier\n * @alias workbox.core.copyResponse\n */\nasync function copyResponse(response, modifier) {\n    const clonedResponse = response.clone();\n    // Create a fresh `ResponseInit` object by cloning the headers.\n    const responseInit = {\n        headers: new Headers(clonedResponse.headers),\n        status: clonedResponse.status,\n        statusText: clonedResponse.statusText,\n    };\n    // Apply any user modifications.\n    const modifiedResponseInit = modifier ? modifier(responseInit) : responseInit;\n    // Create the new response from the body stream and `ResponseInit`\n    // modifications. Note: not all browsers support the Response.body stream,\n    // so fall back to reading the entire body into memory as a blob.\n    const body = canConstructResponseFromBodyStream() ?\n        clonedResponse.body : await clonedResponse.blob();\n    return new Response(body, modifiedResponseInit);\n}\n;\nexport { copyResponse };\n","// @ts-ignore\ntry {\n    self['workbox:precaching:5.0.0-beta.0'] && _();\n}\ncatch (e) { }\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\nconst plugins = [];\nexport const precachePlugins = {\n    /*\n     * @return {Array}\n     * @private\n     */\n    get() {\n        return plugins;\n    },\n    /*\n     * @param {Array} newPlugins\n     * @private\n     */\n    add(newPlugins) {\n        plugins.push(...newPlugins);\n    },\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport '../_version.js';\n// Name of the search parameter used to store revision info.\nconst REVISION_SEARCH_PARAM = '__WB_REVISION__';\n/**\n * Converts a manifest entry into a versioned URL suitable for precaching.\n *\n * @param {Object|string} entry\n * @return {string} A URL with versioning info.\n *\n * @private\n * @memberof module:workbox-precaching\n */\nexport function createCacheKey(entry) {\n    if (!entry) {\n        throw new WorkboxError('add-to-cache-list-unexpected-type', { entry });\n    }\n    // If a precache manifest entry is a string, it's assumed to be a versioned\n    // URL, like '/app.abcd1234.js'. Return as-is.\n    if (typeof entry === 'string') {\n        const urlObject = new URL(entry, location.href);\n        return {\n            cacheKey: urlObject.href,\n            url: urlObject.href,\n        };\n    }\n    const { revision, url } = entry;\n    if (!url) {\n        throw new WorkboxError('add-to-cache-list-unexpected-type', { entry });\n    }\n    // If there's just a URL and no revision, then it's also assumed to be a\n    // versioned URL.\n    if (!revision) {\n        const urlObject = new URL(url, location.href);\n        return {\n            cacheKey: urlObject.href,\n            url: urlObject.href,\n        };\n    }\n    // Otherwise, construct a properly versioned URL using the custom Workbox\n    // search parameter along with the revision info.\n    const cacheKeyURL = new URL(url, location.href);\n    const originalURL = new URL(url, location.href);\n    cacheKeyURL.searchParams.set(REVISION_SEARCH_PARAM, revision);\n    return {\n        cacheKey: cacheKeyURL.href,\n        url: originalURL.href,\n    };\n}\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { cacheWrapper } from 'workbox-core/_private/cacheWrapper.js';\nimport { fetchWrapper } from 'workbox-core/_private/fetchWrapper.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { copyResponse } from 'workbox-core/copyResponse.js';\nimport { createCacheKey } from './utils/createCacheKey.js';\nimport { printCleanupDetails } from './utils/printCleanupDetails.js';\nimport { printInstallDetails } from './utils/printInstallDetails.js';\nimport './_version.js';\n/**\n * Performs efficient precaching of assets.\n *\n * @memberof module:workbox-precaching\n */\nclass PrecacheController {\n    /**\n     * Create a new PrecacheController.\n     *\n     * @param {string} [cacheName] An optional name for the cache, to override\n     * the default precache name.\n     */\n    constructor(cacheName) {\n        this._cacheName = cacheNames.getPrecacheName(cacheName);\n        this._urlsToCacheKeys = new Map();\n        this._cacheKeysToIntegrities = new Map();\n    }\n    /**\n     * This method will add items to the precache list, removing duplicates\n     * and ensuring the information is valid.\n     *\n     * @param {\n     * Array<module:workbox-precaching.PrecacheController.PrecacheEntry|string>\n     * } entries Array of entries to precache.\n     */\n    addToCacheList(entries) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isArray(entries, {\n                moduleName: 'workbox-precaching',\n                className: 'PrecacheController',\n                funcName: 'addToCacheList',\n                paramName: 'entries',\n            });\n        }\n        for (const entry of entries) {\n            const { cacheKey, url } = createCacheKey(entry);\n            if (this._urlsToCacheKeys.has(url) &&\n                this._urlsToCacheKeys.get(url) !== cacheKey) {\n                throw new WorkboxError('add-to-cache-list-conflicting-entries', {\n                    firstEntry: this._urlsToCacheKeys.get(url),\n                    secondEntry: cacheKey,\n                });\n            }\n            if (typeof entry !== 'string' && entry.integrity) {\n                if (this._cacheKeysToIntegrities.has(cacheKey) &&\n                    this._cacheKeysToIntegrities.get(cacheKey) !== entry.integrity) {\n                    throw new WorkboxError('add-to-cache-list-conflicting-integrities', {\n                        url,\n                    });\n                }\n                this._cacheKeysToIntegrities.set(cacheKey, entry.integrity);\n            }\n            this._urlsToCacheKeys.set(url, cacheKey);\n        }\n    }\n    /**\n     * Precaches new and updated assets. Call this method from the service worker\n     * install event.\n     *\n     * @param {Object} options\n     * @param {Event} [options.event] The install event (if needed).\n     * @param {Array<Object>} [options.plugins] Plugins to be used for fetching\n     * and caching during install.\n     * @return {Promise<workbox.precaching.InstallResult>}\n     */\n    async install({ event, plugins } = {}) {\n        if (process.env.NODE_ENV !== 'production') {\n            if (plugins) {\n                assert.isArray(plugins, {\n                    moduleName: 'workbox-precaching',\n                    className: 'PrecacheController',\n                    funcName: 'install',\n                    paramName: 'plugins',\n                });\n            }\n        }\n        const toBePrecached = [];\n        const alreadyPrecached = [];\n        const cache = await caches.open(this._cacheName);\n        const alreadyCachedRequests = await cache.keys();\n        const existingCacheKeys = new Set(alreadyCachedRequests.map((request) => request.url));\n        for (const [url, cacheKey] of this._urlsToCacheKeys) {\n            if (existingCacheKeys.has(cacheKey)) {\n                alreadyPrecached.push(url);\n            }\n            else {\n                toBePrecached.push({ cacheKey, url });\n            }\n        }\n        const precacheRequests = toBePrecached.map(({ cacheKey, url }) => {\n            const integrity = this._cacheKeysToIntegrities.get(cacheKey);\n            return this._addURLToCache({ cacheKey, event, plugins, url, integrity });\n        });\n        await Promise.all(precacheRequests);\n        const updatedURLs = toBePrecached.map((item) => item.url);\n        if (process.env.NODE_ENV !== 'production') {\n            printInstallDetails(updatedURLs, alreadyPrecached);\n        }\n        return {\n            updatedURLs,\n            notUpdatedURLs: alreadyPrecached,\n        };\n    }\n    /**\n     * Deletes assets that are no longer present in the current precache manifest.\n     * Call this method from the service worker activate event.\n     *\n     * @return {Promise<workbox.precaching.CleanupResult>}\n     */\n    async activate() {\n        const cache = await caches.open(this._cacheName);\n        const currentlyCachedRequests = await cache.keys();\n        const expectedCacheKeys = new Set(this._urlsToCacheKeys.values());\n        const deletedURLs = [];\n        for (const request of currentlyCachedRequests) {\n            if (!expectedCacheKeys.has(request.url)) {\n                await cache.delete(request);\n                deletedURLs.push(request.url);\n            }\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            printCleanupDetails(deletedURLs);\n        }\n        return { deletedURLs };\n    }\n    /**\n     * Requests the entry and saves it to the cache if the response is valid.\n     * By default, any response with a status code of less than 400 (including\n     * opaque responses) is considered valid.\n     *\n     * If you need to use custom criteria to determine what's valid and what\n     * isn't, then pass in an item in `options.plugins` that implements the\n     * `cacheWillUpdate()` lifecycle event.\n     *\n     * @private\n     * @param {Object} options\n     * @param {string} options.cacheKey The string to use a cache key.\n     * @param {string} options.url The URL to fetch and cache.\n     * @param {Event} [options.event] The install event (if passed).\n     * @param {Array<Object>} [options.plugins] An array of plugins to apply to\n     * fetch and caching.\n     * @param {string} [options.integrity] The value to use for the `integrity`\n     * field when making the request.\n     */\n    async _addURLToCache({ cacheKey, url, event, plugins, integrity }) {\n        const request = new Request(url, {\n            integrity,\n            cache: 'reload',\n            credentials: 'same-origin',\n        });\n        let response = await fetchWrapper.fetch({\n            event,\n            plugins,\n            request,\n        });\n        // Allow developers to override the default logic about what is and isn't\n        // valid by passing in a plugin implementing cacheWillUpdate(), e.g.\n        // a workbox.cacheableResponse.CacheableResponsePlugin instance.\n        let cacheWillUpdatePlugin;\n        for (const plugin of (plugins || [])) {\n            if ('cacheWillUpdate' in plugin) {\n                cacheWillUpdatePlugin = plugin;\n            }\n        }\n        const isValidResponse = cacheWillUpdatePlugin ?\n            // Use a callback if provided. It returns a truthy value if valid.\n            // NOTE: invoke the method on the plugin instance so the `this` context\n            // is correct.\n            cacheWillUpdatePlugin.cacheWillUpdate({ event, request, response }) :\n            // Otherwise, default to considering any response status under 400 valid.\n            // This includes, by default, considering opaque responses valid.\n            response.status < 400;\n        // Consider this a failure, leading to the `install` handler failing, if\n        // we get back an invalid response.\n        if (!isValidResponse) {\n            throw new WorkboxError('bad-precaching-response', {\n                url,\n                status: response.status,\n            });\n        }\n        // Redirected responses cannot be used to satisfy a navigation request, so\n        // any redirected response must be \"copied\" rather than cloned, so the new\n        // response doesn't contain the `redirected` flag. See:\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=669363&desc=2#c1\n        if (response.redirected) {\n            response = await copyResponse(response);\n        }\n        await cacheWrapper.put({\n            event,\n            plugins,\n            response,\n            // `request` already uses `url`. We may be able to reuse it.\n            request: cacheKey === url ? request : new Request(cacheKey),\n            cacheName: this._cacheName,\n            matchOptions: {\n                ignoreSearch: true,\n            },\n        });\n    }\n    /**\n     * Returns a mapping of a precached URL to the corresponding cache key, taking\n     * into account the revision information for the URL.\n     *\n     * @return {Map<string, string>} A URL to cache key mapping.\n     */\n    getURLsToCacheKeys() {\n        return this._urlsToCacheKeys;\n    }\n    /**\n     * Returns a list of all the URLs that have been precached by the current\n     * service worker.\n     *\n     * @return {Array<string>} The precached URLs.\n     */\n    getCachedURLs() {\n        return [...this._urlsToCacheKeys.keys()];\n    }\n    /**\n     * Returns the cache key used for storing a given URL. If that URL is\n     * unversioned, like `/index.html', then the cache key will be the original\n     * URL with a search parameter appended to it.\n     *\n     * @param {string} url A URL whose cache key you want to look up.\n     * @return {string} The versioned URL that corresponds to a cache key\n     * for the original URL, or undefined if that URL isn't precached.\n     */\n    getCacheKeyForURL(url) {\n        const urlObject = new URL(url, location.href);\n        return this._urlsToCacheKeys.get(urlObject.href);\n    }\n    /**\n     * Returns a function that looks up `url` in the precache (taking into\n     * account revision information), and returns the corresponding `Response`.\n     *\n     * If for an unexpected reason there is a cache miss when looking up `url`,\n     * this will fall back to retrieving the `Response` via `fetch()`.\n     *\n     * @param {string} url The precached URL which will be used to lookup the\n     * `Response`.\n     * @return {workbox.routing.Route~handlerCallback}\n     */\n    createHandlerForURL(url) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isType(url, 'string', {\n                moduleName: 'workbox-precaching',\n                funcName: 'createHandlerForURL',\n                paramName: 'url',\n            });\n        }\n        const cacheKey = this.getCacheKeyForURL(url);\n        if (!cacheKey) {\n            throw new WorkboxError('non-precached-url', { url });\n        }\n        return async () => {\n            try {\n                const cache = await caches.open(this._cacheName);\n                const response = await cache.match(cacheKey);\n                if (response) {\n                    return response;\n                }\n                // This shouldn't normally happen, but there are edge cases:\n                // https://github.com/GoogleChrome/workbox/issues/1441\n                throw new Error(`The cache ${this._cacheName} did not have an entry ` +\n                    `for ${cacheKey}.`);\n            }\n            catch (error) {\n                // If there's either a cache miss, or the caches.match() call threw\n                // an exception, then attempt to fulfill the navigation request with\n                // a response from the network rather than leaving the user with a\n                // failed navigation.\n                if (process.env.NODE_ENV !== 'production') {\n                    logger.debug(`Unable to respond to navigation request with ` +\n                        `cached response. Falling back to network.`, error);\n                }\n                // This might still fail if the browser is offline...\n                return fetch(cacheKey);\n            }\n        };\n    }\n    ;\n}\nexport { PrecacheController };\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { PrecacheController } from '../PrecacheController.js';\nimport '../_version.js';\nlet precacheController;\n/**\n * @return {PrecacheController}\n * @private\n */\nexport const getOrCreatePrecacheController = () => {\n    if (!precacheController) {\n        precacheController = new PrecacheController();\n    }\n    return precacheController;\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { getOrCreatePrecacheController } from './getOrCreatePrecacheController.js';\nimport { generateURLVariations } from './generateURLVariations.js';\nimport '../_version.js';\n/**\n * This function will take the request URL and manipulate it based on the\n * configuration options.\n *\n * @param {string} url\n * @param {Object} options\n * @return {string} Returns the URL in the cache that matches the request,\n * if possible.\n *\n * @private\n */\nexport const getCacheKeyForURL = (url, options) => {\n    const precacheController = getOrCreatePrecacheController();\n    const urlsToCacheKeys = precacheController.getURLsToCacheKeys();\n    for (const possibleURL of generateURLVariations(url, options)) {\n        const possibleCacheKey = urlsToCacheKeys.get(possibleURL);\n        if (possibleCacheKey) {\n            return possibleCacheKey;\n        }\n    }\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { removeIgnoredSearchParams } from './removeIgnoredSearchParams.js';\nimport '../_version.js';\n/**\n * Generator function that yields possible variations on the original URL to\n * check, one at a time.\n *\n * @param {string} url\n * @param {Object} options\n *\n * @private\n * @memberof module:workbox-precaching\n */\nexport function* generateURLVariations(url, { ignoreURLParametersMatching, directoryIndex, cleanURLs, urlManipulation, } = {}) {\n    const urlObject = new URL(url, location.href);\n    urlObject.hash = '';\n    yield urlObject.href;\n    const urlWithoutIgnoredParams = removeIgnoredSearchParams(urlObject, ignoreURLParametersMatching);\n    yield urlWithoutIgnoredParams.href;\n    if (directoryIndex && urlWithoutIgnoredParams.pathname.endsWith('/')) {\n        const directoryURL = new URL(urlWithoutIgnoredParams.href);\n        directoryURL.pathname += directoryIndex;\n        yield directoryURL.href;\n    }\n    if (cleanURLs) {\n        const cleanURL = new URL(urlWithoutIgnoredParams.href);\n        cleanURL.pathname += '.html';\n        yield cleanURL.href;\n    }\n    if (urlManipulation) {\n        const additionalURLs = urlManipulation({ url: urlObject });\n        for (const urlToAttempt of additionalURLs) {\n            yield urlToAttempt.href;\n        }\n    }\n}\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * Removes any URL search parameters that should be ignored.\n *\n * @param {URL} urlObject The original URL.\n * @param {Array<RegExp>} ignoreURLParametersMatching RegExps to test against\n * each search parameter name. Matches mean that the search parameter should be\n * ignored.\n * @return {URL} The URL with any ignored search parameters removed.\n *\n * @private\n * @memberof module:workbox-precaching\n */\nexport function removeIgnoredSearchParams(urlObject, ignoreURLParametersMatching = []) {\n    // Convert the iterable into an array at the start of the loop to make sure\n    // deletion doesn't mess up iteration.\n    for (const paramName of [...urlObject.searchParams.keys()]) {\n        if (ignoreURLParametersMatching.some((regExp) => regExp.test(paramName))) {\n            urlObject.searchParams.delete(paramName);\n        }\n    }\n    return urlObject;\n}\n","/*\n  Copyright 2019 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { addFetchListener } from './utils/addFetchListener.js';\nimport './_version.js';\nlet listenerAdded = false;\n/**\n * Add a `fetch` listener to the service worker that will\n * respond to\n * [network requests]{@link https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers#Custom_responses_to_requests}\n * with precached assets.\n *\n * Requests for assets that aren't precached, the `FetchEvent` will not be\n * responded to, allowing the event to fall through to other `fetch` event\n * listeners.\n *\n * @param {Object} [options]\n * @param {string} [options.directoryIndex=index.html] The `directoryIndex` will\n * check cache entries for a URLs ending with '/' to see if there is a hit when\n * appending the `directoryIndex` value.\n * @param {Array<RegExp>} [options.ignoreURLParametersMatching=[/^utm_/]] An\n * array of regex's to remove search params when looking for a cache match.\n * @param {boolean} [options.cleanURLs=true] The `cleanURLs` option will\n * check the cache for the URL with a `.html` added to the end of the end.\n * @param {workbox.precaching~urlManipulation} [options.urlManipulation]\n * This is a function that should take a URL and return an array of\n * alternative URLs that should be checked for precache matches.\n *\n * @alias workbox.precaching.addRoute\n */\nexport const addRoute = (options) => {\n    if (!listenerAdded) {\n        addFetchListener(options);\n        listenerAdded = true;\n    }\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { getCacheKeyForURL } from './getCacheKeyForURL.js';\nimport '../_version.js';\n/**\n * Adds a `fetch` listener to the service worker that will\n * respond to\n * [network requests]{@link https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers#Custom_responses_to_requests}\n * with precached assets.\n *\n * Requests for assets that aren't precached, the `FetchEvent` will not be\n * responded to, allowing the event to fall through to other `fetch` event\n * listeners.\n *\n * NOTE: when called more than once this method will replace the previously set\n * configuration options. Calling it more than once is not recommended outside\n * of tests.\n *\n * @private\n * @param {Object} [options]\n * @param {string} [options.directoryIndex=index.html] The `directoryIndex` will\n * check cache entries for a URLs ending with '/' to see if there is a hit when\n * appending the `directoryIndex` value.\n * @param {Array<RegExp>} [options.ignoreURLParametersMatching=[/^utm_/]] An\n * array of regex's to remove search params when looking for a cache match.\n * @param {boolean} [options.cleanURLs=true] The `cleanURLs` option will\n * check the cache for the URL with a `.html` added to the end of the end.\n * @param {workbox.precaching~urlManipulation} [options.urlManipulation]\n * This is a function that should take a URL and return an array of\n * alternative URLs that should be checked for precache matches.\n */\nexport const addFetchListener = ({ ignoreURLParametersMatching = [/^utm_/], directoryIndex = 'index.html', cleanURLs = true, urlManipulation, } = {}) => {\n    const cacheName = cacheNames.getPrecacheName();\n    addEventListener('fetch', (event) => {\n        const precachedURL = getCacheKeyForURL(event.request.url, {\n            cleanURLs,\n            directoryIndex,\n            ignoreURLParametersMatching,\n            urlManipulation,\n        });\n        if (!precachedURL) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.debug(`Precaching did not find a match for ` +\n                    getFriendlyURL(event.request.url));\n            }\n            return;\n        }\n        let responsePromise = caches.open(cacheName).then((cache) => {\n            return cache.match(precachedURL);\n        }).then((cachedResponse) => {\n            if (cachedResponse) {\n                return cachedResponse;\n            }\n            // Fall back to the network if we don't have a cached response\n            // (perhaps due to manual cache cleanup).\n            if (process.env.NODE_ENV !== 'production') {\n                logger.warn(`The precached response for ` +\n                    `${getFriendlyURL(precachedURL)} in ${cacheName} was not found. ` +\n                    `Falling back to the network instead.`);\n            }\n            return fetch(precachedURL);\n        });\n        if (process.env.NODE_ENV !== 'production') {\n            responsePromise = responsePromise.then((response) => {\n                // Workbox is going to handle the route.\n                // print the routing details to the console.\n                logger.groupCollapsed(`Precaching is responding to: ` +\n                    getFriendlyURL(event.request.url));\n                logger.log(`Serving the precached url: ${precachedURL}`);\n                logger.groupCollapsed(`View request details here.`);\n                logger.log(event.request);\n                logger.groupEnd();\n                logger.groupCollapsed(`View response details here.`);\n                logger.log(response);\n                logger.groupEnd();\n                logger.groupEnd();\n                return response;\n            });\n        }\n        event.respondWith(responsePromise);\n    });\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { getOrCreatePrecacheController } from './utils/getOrCreatePrecacheController.js';\nimport { precachePlugins } from './utils/precachePlugins.js';\nimport './_version.js';\nconst installListener = (event) => {\n    const precacheController = getOrCreatePrecacheController();\n    const plugins = precachePlugins.get();\n    event.waitUntil(precacheController.install({ event, plugins })\n        .catch((error) => {\n        if (process.env.NODE_ENV !== 'production') {\n            logger.error(`Service worker installation failed. It will ` +\n                `be retried automatically during the next navigation.`);\n        }\n        // Re-throw the error to ensure installation fails.\n        throw error;\n    }));\n};\nconst activateListener = (event) => {\n    const precacheController = getOrCreatePrecacheController();\n    event.waitUntil(precacheController.activate());\n};\n/**\n * Adds items to the precache list, removing any duplicates and\n * stores the files in the\n * [\"precache cache\"]{@link module:workbox-core.cacheNames} when the service\n * worker installs.\n *\n * This method can be called multiple times.\n *\n * Please note: This method **will not** serve any of the cached files for you.\n * It only precaches files. To respond to a network request you call\n * [addRoute()]{@link module:workbox-precaching.addRoute}.\n *\n * If you have a single array of files to precache, you can just call\n * [precacheAndRoute()]{@link module:workbox-precaching.precacheAndRoute}.\n *\n * @param {Array<Object|string>} [entries=[]] Array of entries to precache.\n *\n * @alias workbox.precaching.precache\n */\nexport const precache = (entries) => {\n    const precacheController = getOrCreatePrecacheController();\n    precacheController.addToCacheList(entries);\n    if (entries.length > 0) {\n        // NOTE: these listeners will only be added once (even if the `precache()`\n        // method is called multiple times) because event listeners are implemented\n        // as a set, where each listener must be unique.\n        addEventListener('install', installListener);\n        addEventListener('activate', activateListener);\n    }\n};\n","// @ts-ignore\ntry {\n    self['workbox:range-requests:5.0.0-beta.0'] && _();\n}\ncatch (e) { }\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { calculateEffectiveBoundaries } from './utils/calculateEffectiveBoundaries.js';\nimport { parseRangeHeader } from './utils/parseRangeHeader.js';\nimport './_version.js';\n/**\n * Given a `Request` and `Response` objects as input, this will return a\n * promise for a new `Response`.\n *\n * If the original `Response` already contains partial content (i.e. it has\n * a status of 206), then this assumes it already fulfills the `Range:`\n * requirements, and will return it as-is.\n *\n * @param {Request} request A request, which should contain a Range:\n * header.\n * @param {Response} originalResponse A response.\n * @return {Promise<Response>} Either a `206 Partial Content` response, with\n * the response body set to the slice of content specified by the request's\n * `Range:` header, or a `416 Range Not Satisfiable` response if the\n * conditions of the `Range:` header can't be met.\n *\n * @memberof workbox.rangeRequests\n */\nasync function createPartialResponse(request, originalResponse) {\n    try {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-range-requests',\n                funcName: 'createPartialResponse',\n                paramName: 'request',\n            });\n            assert.isInstance(originalResponse, Response, {\n                moduleName: 'workbox-range-requests',\n                funcName: 'createPartialResponse',\n                paramName: 'originalResponse',\n            });\n        }\n        if (originalResponse.status === 206) {\n            // If we already have a 206, then just pass it through as-is;\n            // see https://github.com/GoogleChrome/workbox/issues/1720\n            return originalResponse;\n        }\n        const rangeHeader = request.headers.get('range');\n        if (!rangeHeader) {\n            throw new WorkboxError('no-range-header');\n        }\n        const boundaries = parseRangeHeader(rangeHeader);\n        const originalBlob = await originalResponse.blob();\n        const effectiveBoundaries = calculateEffectiveBoundaries(originalBlob, boundaries.start, boundaries.end);\n        const slicedBlob = originalBlob.slice(effectiveBoundaries.start, effectiveBoundaries.end);\n        const slicedBlobSize = slicedBlob.size;\n        const slicedResponse = new Response(slicedBlob, {\n            // Status code 206 is for a Partial Content response.\n            // See https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/206\n            status: 206,\n            statusText: 'Partial Content',\n            headers: originalResponse.headers,\n        });\n        slicedResponse.headers.set('Content-Length', String(slicedBlobSize));\n        slicedResponse.headers.set('Content-Range', `bytes ${effectiveBoundaries.start}-${effectiveBoundaries.end - 1}/` +\n            originalBlob.size);\n        return slicedResponse;\n    }\n    catch (error) {\n        if (process.env.NODE_ENV !== 'production') {\n            logger.warn(`Unable to construct a partial response; returning a ` +\n                `416 Range Not Satisfiable response instead.`);\n            logger.groupCollapsed(`View details here.`);\n            logger.log(error);\n            logger.log(request);\n            logger.log(originalResponse);\n            logger.groupEnd();\n        }\n        return new Response('', {\n            status: 416,\n            statusText: 'Range Not Satisfiable',\n        });\n    }\n}\nexport { createPartialResponse };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { assert } from 'workbox-core/_private/assert.js';\nimport '../_version.js';\n/**\n * @param {string} rangeHeader A Range: header value.\n * @return {Object} An object with `start` and `end` properties, reflecting\n * the parsed value of the Range: header. If either the `start` or `end` are\n * omitted, then `null` will be returned.\n *\n * @private\n */\nfunction parseRangeHeader(rangeHeader) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert.isType(rangeHeader, 'string', {\n            moduleName: 'workbox-range-requests',\n            funcName: 'parseRangeHeader',\n            paramName: 'rangeHeader',\n        });\n    }\n    const normalizedRangeHeader = rangeHeader.trim().toLowerCase();\n    if (!normalizedRangeHeader.startsWith('bytes=')) {\n        throw new WorkboxError('unit-must-be-bytes', { normalizedRangeHeader });\n    }\n    // Specifying multiple ranges separate by commas is valid syntax, but this\n    // library only attempts to handle a single, contiguous sequence of bytes.\n    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Range#Syntax\n    if (normalizedRangeHeader.includes(',')) {\n        throw new WorkboxError('single-range-only', { normalizedRangeHeader });\n    }\n    const rangeParts = /(\\d*)-(\\d*)/.exec(normalizedRangeHeader);\n    // We need either at least one of the start or end values.\n    if (!rangeParts || !(rangeParts[1] || rangeParts[2])) {\n        throw new WorkboxError('invalid-range-values', { normalizedRangeHeader });\n    }\n    return {\n        start: rangeParts[1] === '' ? undefined : Number(rangeParts[1]),\n        end: rangeParts[2] === '' ? undefined : Number(rangeParts[2]),\n    };\n}\nexport { parseRangeHeader };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { assert } from 'workbox-core/_private/assert.js';\nimport '../_version.js';\n/**\n * @param {Blob} blob A source blob.\n * @param {number} [start] The offset to use as the start of the\n * slice.\n * @param {number} [end] The offset to use as the end of the slice.\n * @return {Object} An object with `start` and `end` properties, reflecting\n * the effective boundaries to use given the size of the blob.\n *\n * @private\n */\nfunction calculateEffectiveBoundaries(blob, start, end) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert.isInstance(blob, Blob, {\n            moduleName: 'workbox-range-requests',\n            funcName: 'calculateEffectiveBoundaries',\n            paramName: 'blob',\n        });\n    }\n    const blobSize = blob.size;\n    if ((end && end > blobSize) || (start && start < 0)) {\n        throw new WorkboxError('range-not-satisfiable', {\n            size: blobSize,\n            end,\n            start,\n        });\n    }\n    let effectiveStart;\n    let effectiveEnd;\n    if (start !== undefined && end !== undefined) {\n        effectiveStart = start;\n        // Range values are inclusive, so add 1 to the value.\n        effectiveEnd = end + 1;\n    }\n    else if (start !== undefined && end === undefined) {\n        effectiveStart = start;\n        effectiveEnd = blobSize;\n    }\n    else if (end !== undefined && start === undefined) {\n        effectiveStart = blobSize - end;\n        effectiveEnd = blobSize;\n    }\n    return {\n        start: effectiveStart,\n        end: effectiveEnd,\n    };\n}\nexport { calculateEffectiveBoundaries };\n","// @ts-ignore\ntry {\n    self['workbox:routing:5.0.0-beta.0'] && _();\n}\ncatch (e) { }\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * The default HTTP method, 'GET', used when there's no specific method\n * configured for a route.\n *\n * @type {string}\n *\n * @private\n */\nexport const defaultMethod = 'GET';\n/**\n * The list of valid HTTP methods associated with requests that could be routed.\n *\n * @type {Array<string>}\n *\n * @private\n */\nexport const validMethods = [\n    'DELETE',\n    'GET',\n    'HEAD',\n    'PATCH',\n    'POST',\n    'PUT',\n];\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport '../_version.js';\n/**\n * @param {function()|Object} handler Either a function, or an object with a\n * 'handle' method.\n * @return {Object} An object with a handle method.\n *\n * @private\n */\nexport const normalizeHandler = (handler) => {\n    if (handler && typeof handler === 'object') {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.hasMethod(handler, 'handle', {\n                moduleName: 'workbox-routing',\n                className: 'Route',\n                funcName: 'constructor',\n                paramName: 'handler',\n            });\n        }\n        return handler;\n    }\n    else {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isType(handler, 'function', {\n                moduleName: 'workbox-routing',\n                className: 'Route',\n                funcName: 'constructor',\n                paramName: 'handler',\n            });\n        }\n        return { handle: handler };\n    }\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { defaultMethod, validMethods } from './utils/constants.js';\nimport { normalizeHandler } from './utils/normalizeHandler.js';\nimport './_version.js';\n/**\n * A `Route` consists of a pair of callback functions, \"match\" and \"handler\".\n * The \"match\" callback determine if a route should be used to \"handle\" a\n * request by returning a non-falsy value if it can. The \"handler\" callback\n * is called when there is a match and should return a Promise that resolves\n * to a `Response`.\n *\n * @memberof workbox.routing\n */\nclass Route {\n    /**\n     * Constructor for Route class.\n     *\n     * @param {workbox.routing.Route~matchCallback} match\n     * A callback function that determines whether the route matches a given\n     * `fetch` event by returning a non-falsy value.\n     * @param {workbox.routing.Route~handlerCallback} handler A callback\n     * function that returns a Promise resolving to a Response.\n     * @param {string} [method='GET'] The HTTP method to match the Route\n     * against.\n     */\n    constructor(match, handler, method = defaultMethod) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isType(match, 'function', {\n                moduleName: 'workbox-routing',\n                className: 'Route',\n                funcName: 'constructor',\n                paramName: 'match',\n            });\n            if (method) {\n                assert.isOneOf(method, validMethods, { paramName: 'method' });\n            }\n        }\n        // These values are referenced directly by Router so cannot be\n        // altered by minifification.\n        this.handler = normalizeHandler(handler);\n        this.match = match;\n        this.method = method;\n    }\n}\nexport { Route };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { Route } from './Route.js';\nimport './_version.js';\n/**\n * RegExpRoute makes it easy to create a regular expression based\n * [Route]{@link workbox.routing.Route}.\n *\n * For same-origin requests the RegExp only needs to match part of the URL. For\n * requests against third-party servers, you must define a RegExp that matches\n * the start of the URL.\n *\n * [See the module docs for info.]{@link https://developers.google.com/web/tools/workbox/modules/workbox-routing}\n *\n * @memberof workbox.routing\n * @extends workbox.routing.Route\n */\nclass RegExpRoute extends Route {\n    /**\n     * If the regulard expression contains\n     * [capture groups]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#grouping-back-references},\n     * th ecaptured values will be passed to the\n     * [handler's]{@link workbox.routing.Route~handlerCallback} `params`\n     * argument.\n     *\n     * @param {RegExp} regExp The regular expression to match against URLs.\n     * @param {workbox.routing.Route~handlerCallback} handler A callback\n     * function that returns a Promise resulting in a Response.\n     * @param {string} [method='GET'] The HTTP method to match the Route\n     * against.\n     */\n    constructor(regExp, handler, method) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(regExp, RegExp, {\n                moduleName: 'workbox-routing',\n                className: 'RegExpRoute',\n                funcName: 'constructor',\n                paramName: 'pattern',\n            });\n        }\n        const match = ({ url }) => {\n            const result = regExp.exec(url.href);\n            // Return immediately if there's no match.\n            if (!result) {\n                return;\n            }\n            // Require that the match start at the first character in the URL string\n            // if it's a cross-origin request.\n            // See https://github.com/GoogleChrome/workbox/issues/281 for the context\n            // behind this behavior.\n            if ((url.origin !== location.origin) && (result.index !== 0)) {\n                if (process.env.NODE_ENV !== 'production') {\n                    logger.debug(`The regular expression '${regExp}' only partially matched ` +\n                        `against the cross-origin URL '${url}'. RegExpRoute's will only ` +\n                        `handle cross-origin requests if they match the entire URL.`);\n                }\n                return;\n            }\n            // If the route matches, but there aren't any capture groups defined, then\n            // this will return [], which is truthy and therefore sufficient to\n            // indicate a match.\n            // If there are capture groups, then it will return their values.\n            return result.slice(1);\n        };\n        super(match, handler, method);\n    }\n}\nexport { RegExpRoute };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { normalizeHandler } from './utils/normalizeHandler.js';\nimport './_version.js';\n/**\n * The Router can be used to process a FetchEvent through one or more\n * [Routes]{@link workbox.routing.Route} responding  with a Request if\n * a matching route exists.\n *\n * If no route matches a given a request, the Router will use a \"default\"\n * handler if one is defined.\n *\n * Should the matching Route throw an error, the Router will use a \"catch\"\n * handler if one is defined to gracefully deal with issues and respond with a\n * Request.\n *\n * If a request matches multiple routes, the **earliest** registered route will\n * be used to respond to the request.\n *\n * @memberof workbox.routing\n */\nclass Router {\n    /**\n     * Initializes a new Router.\n     */\n    constructor() {\n        this._routes = new Map();\n    }\n    /**\n     * @return {Map<string, Array<workbox.routing.Route>>} routes A `Map` of HTTP\n     * method name ('GET', etc.) to an array of all the corresponding `Route`\n     * instances that are registered.\n     */\n    get routes() {\n        return this._routes;\n    }\n    /**\n     * Adds a fetch event listener to respond to events when a route matches\n     * the event's request.\n     */\n    addFetchListener() {\n        self.addEventListener('fetch', (event) => {\n            const { request } = event;\n            const responsePromise = this.handleRequest({ request, event });\n            if (responsePromise) {\n                event.respondWith(responsePromise);\n            }\n        });\n    }\n    /**\n     * Adds a message event listener for URLs to cache from the window.\n     * This is useful to cache resources loaded on the page prior to when the\n     * service worker started controlling it.\n     *\n     * The format of the message data sent from the window should be as follows.\n     * Where the `urlsToCache` array may consist of URL strings or an array of\n     * URL string + `requestInit` object (the same as you'd pass to `fetch()`).\n     *\n     * ```\n     * {\n     *   type: 'CACHE_URLS',\n     *   payload: {\n     *     urlsToCache: [\n     *       './script1.js',\n     *       './script2.js',\n     *       ['./script3.js', {mode: 'no-cors'}],\n     *     ],\n     *   },\n     * }\n     * ```\n     */\n    addCacheListener() {\n        self.addEventListener('message', async (event) => {\n            if (event.data && event.data.type === 'CACHE_URLS') {\n                const { payload } = event.data;\n                if (process.env.NODE_ENV !== 'production') {\n                    logger.debug(`Caching URLs from the window`, payload.urlsToCache);\n                }\n                const requestPromises = Promise.all(payload.urlsToCache.map((entry) => {\n                    if (typeof entry === 'string') {\n                        entry = [entry];\n                    }\n                    const request = new Request(...entry);\n                    return this.handleRequest({ request });\n                    // TODO(philipwalton): TypeScript errors without this typecast for\n                    // some reason (probably a bug). The real type here should work but\n                    // doesn't: `Array<Promise<Response> | undefined>`.\n                })); // TypeScript\n                event.waitUntil(requestPromises);\n                // If a MessageChannel was used, reply to the message on success.\n                if (event.ports && event.ports[0]) {\n                    await requestPromises;\n                    event.ports[0].postMessage(true);\n                }\n            }\n        });\n    }\n    /**\n     * Apply the routing rules to a FetchEvent object to get a Response from an\n     * appropriate Route's handler.\n     *\n     * @param {Object} options\n     * @param {Request} options.request The request to handle (this is usually\n     *     from a fetch event, but it does not have to be).\n     * @param {FetchEvent} [options.event] The event that triggered the request,\n     *     if applicable.\n     * @return {Promise<Response>|undefined} A promise is returned if a\n     *     registered route can handle the request. If there is no matching\n     *     route and there's no `defaultHandler`, `undefined` is returned.\n     */\n    handleRequest({ request, event }) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'handleRequest',\n                paramName: 'options.request',\n            });\n        }\n        const url = new URL(request.url, location.href);\n        if (!url.protocol.startsWith('http')) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.debug(`Workbox Router only supports URLs that start with 'http'.`);\n            }\n            return;\n        }\n        let { params, route } = this.findMatchingRoute({ url, request, event });\n        let handler = route && route.handler;\n        let debugMessages = [];\n        if (process.env.NODE_ENV !== 'production') {\n            if (handler) {\n                debugMessages.push([\n                    `Found a route to handle this request:`, route,\n                ]);\n                if (params) {\n                    debugMessages.push([\n                        `Passing the following params to the route's handler:`, params,\n                    ]);\n                }\n            }\n        }\n        // If we don't have a handler because there was no matching route, then\n        // fall back to defaultHandler if that's defined.\n        if (!handler && this._defaultHandler) {\n            if (process.env.NODE_ENV !== 'production') {\n                debugMessages.push(`Failed to find a matching route. Falling ` +\n                    `back to the default handler.`);\n            }\n            handler = this._defaultHandler;\n        }\n        if (!handler) {\n            if (process.env.NODE_ENV !== 'production') {\n                // No handler so Workbox will do nothing. If logs is set of debug\n                // i.e. verbose, we should print out this information.\n                logger.debug(`No route found for: ${getFriendlyURL(url)}`);\n            }\n            return;\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            // We have a handler, meaning Workbox is going to handle the route.\n            // print the routing details to the console.\n            logger.groupCollapsed(`Router is responding to: ${getFriendlyURL(url)}`);\n            debugMessages.forEach((msg) => {\n                if (Array.isArray(msg)) {\n                    logger.log(...msg);\n                }\n                else {\n                    logger.log(msg);\n                }\n            });\n            // The Request and Response objects contains a great deal of information,\n            // hide it under a group in case developers want to see it.\n            logger.groupCollapsed(`View request details here.`);\n            logger.log(request);\n            logger.groupEnd();\n            logger.groupEnd();\n        }\n        // Wrap in try and catch in case the handle method throws a synchronous\n        // error. It should still callback to the catch handler.\n        let responsePromise;\n        try {\n            responsePromise = handler.handle({ url, request, event, params });\n        }\n        catch (err) {\n            responsePromise = Promise.reject(err);\n        }\n        if (responsePromise && this._catchHandler) {\n            responsePromise = responsePromise.catch((err) => {\n                if (process.env.NODE_ENV !== 'production') {\n                    // Still include URL here as it will be async from the console group\n                    // and may not make sense without the URL\n                    logger.groupCollapsed(`Error thrown when responding to: ` +\n                        ` ${getFriendlyURL(url)}. Falling back to Catch Handler.`);\n                    logger.error(`Error thrown by:`, route);\n                    logger.error(err);\n                    logger.groupEnd();\n                }\n                return this._catchHandler.handle({ url, request, event });\n            });\n        }\n        return responsePromise;\n    }\n    /**\n     * Checks a request and URL (and optionally an event) against the list of\n     * registered routes, and if there's a match, returns the corresponding\n     * route along with any params generated by the match.\n     *\n     * @param {Object} options\n     * @param {URL} options.url\n     * @param {Request} options.request The request to match.\n     * @param {Event} [options.event] The corresponding event (unless N/A).\n     * @return {Object} An object with `route` and `params` properties.\n     *     They are populated if a matching route was found or `undefined`\n     *     otherwise.\n     */\n    findMatchingRoute({ url, request, event }) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(url, URL, {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'findMatchingRoute',\n                paramName: 'options.url',\n            });\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'findMatchingRoute',\n                paramName: 'options.request',\n            });\n        }\n        const routes = this._routes.get(request.method) || [];\n        for (const route of routes) {\n            let params;\n            let matchResult = route.match({ url, request, event });\n            if (matchResult) {\n                // See https://github.com/GoogleChrome/workbox/issues/2079\n                params = matchResult;\n                if (Array.isArray(matchResult) && matchResult.length === 0) {\n                    // Instead of passing an empty array in as params, use undefined.\n                    params = undefined;\n                }\n                else if ((matchResult.constructor === Object &&\n                    Object.keys(matchResult).length === 0)) {\n                    // Instead of passing an empty object in as params, use undefined.\n                    params = undefined;\n                }\n                else if (typeof matchResult === 'boolean') {\n                    // For the boolean value true (rather than just something truth-y),\n                    // don't set params.\n                    // See https://github.com/GoogleChrome/workbox/pull/2134#issuecomment-513924353\n                    params = undefined;\n                }\n                // Return early if have a match.\n                return { route, params };\n            }\n        }\n        // If no match was found above, return and empty object.\n        return {};\n    }\n    /**\n     * Define a default `handler` that's called when no routes explicitly\n     * match the incoming request.\n     *\n     * Without a default handler, unmatched requests will go against the\n     * network as if there were no service worker present.\n     *\n     * @param {workbox.routing.Route~handlerCallback} handler A callback\n     * function that returns a Promise resulting in a Response.\n     */\n    setDefaultHandler(handler) {\n        this._defaultHandler = normalizeHandler(handler);\n    }\n    /**\n     * If a Route throws an error while handling a request, this `handler`\n     * will be called and given a chance to provide a response.\n     *\n     * @param {workbox.routing.Route~handlerCallback} handler A callback\n     * function that returns a Promise resulting in a Response.\n     */\n    setCatchHandler(handler) {\n        this._catchHandler = normalizeHandler(handler);\n    }\n    /**\n     * Registers a route with the router.\n     *\n     * @param {workbox.routing.Route} route The route to register.\n     */\n    registerRoute(route) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isType(route, 'object', {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'registerRoute',\n                paramName: 'route',\n            });\n            assert.hasMethod(route, 'match', {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'registerRoute',\n                paramName: 'route',\n            });\n            assert.isType(route.handler, 'object', {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'registerRoute',\n                paramName: 'route',\n            });\n            assert.hasMethod(route.handler, 'handle', {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'registerRoute',\n                paramName: 'route.handler',\n            });\n            assert.isType(route.method, 'string', {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'registerRoute',\n                paramName: 'route.method',\n            });\n        }\n        if (!this._routes.has(route.method)) {\n            this._routes.set(route.method, []);\n        }\n        // Give precedence to all of the earlier routes by adding this additional\n        // route to the end of the array.\n        this._routes.get(route.method).push(route);\n    }\n    /**\n     * Unregisters a route with the router.\n     *\n     * @param {workbox.routing.Route} route The route to unregister.\n     */\n    unregisterRoute(route) {\n        if (!this._routes.has(route.method)) {\n            throw new WorkboxError('unregister-route-but-not-found-with-method', {\n                method: route.method,\n            });\n        }\n        const routeIndex = this._routes.get(route.method).indexOf(route);\n        if (routeIndex > -1) {\n            this._routes.get(route.method).splice(routeIndex, 1);\n        }\n        else {\n            throw new WorkboxError('unregister-route-route-not-registered');\n        }\n    }\n}\nexport { Router };\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { Router } from '../Router.js';\nimport '../_version.js';\nlet defaultRouter;\n/**\n * Creates a new, singleton Router instance if one does not exist. If one\n * does already exist, that instance is returned.\n *\n * @private\n * @return {Router}\n */\nexport const getOrCreateDefaultRouter = () => {\n    if (!defaultRouter) {\n        defaultRouter = new Router();\n        // The helpers that use the default Router assume these listeners exist.\n        defaultRouter.addFetchListener();\n        defaultRouter.addCacheListener();\n    }\n    return defaultRouter;\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { Route } from './Route.js';\nimport { RegExpRoute } from './RegExpRoute.js';\nimport { getOrCreateDefaultRouter } from './utils/getOrCreateDefaultRouter.js';\nimport './_version.js';\n/**\n * Easily register a RegExp, string, or function with a caching\n * strategy to a singleton Router instance.\n *\n * This method will generate a Route for you if needed and\n * call [Router.registerRoute()]{@link\n * workbox.routing.Router#registerRoute}.\n *\n * @param {\n * RegExp|\n * string|\n * workbox.routing.Route~matchCallback|\n * workbox.routing.Route\n * } capture\n * If the capture param is a `Route`, all other arguments will be ignored.\n * @param {workbox.routing.Route~handlerCallback} [handler] A callback\n * function that returns a Promise resulting in a Response. This parameter\n * is required if `capture` is not a `Route` object.\n * @param {string} [method='GET'] The HTTP method to match the Route\n * against.\n * @return {workbox.routing.Route} The generated `Route`(Useful for\n * unregistering).\n *\n * @alias workbox.routing.registerRoute\n */\nexport const registerRoute = (capture, handler, method) => {\n    let route;\n    if (typeof capture === 'string') {\n        const captureUrl = new URL(capture, location.href);\n        if (process.env.NODE_ENV !== 'production') {\n            if (!(capture.startsWith('/') || capture.startsWith('http'))) {\n                throw new WorkboxError('invalid-string', {\n                    moduleName: 'workbox-routing',\n                    funcName: 'registerRoute',\n                    paramName: 'capture',\n                });\n            }\n            // We want to check if Express-style wildcards are in the pathname only.\n            // TODO: Remove this log message in v4.\n            const valueToCheck = capture.startsWith('http') ?\n                captureUrl.pathname : capture;\n            // See https://github.com/pillarjs/path-to-regexp#parameters\n            const wildcards = '[*:?+]';\n            if (valueToCheck.match(new RegExp(`${wildcards}`))) {\n                logger.debug(`The '$capture' parameter contains an Express-style wildcard ` +\n                    `character (${wildcards}). Strings are now always interpreted as ` +\n                    `exact matches; use a RegExp for partial or wildcard matches.`);\n            }\n        }\n        const matchCallback = ({ url }) => {\n            if (process.env.NODE_ENV !== 'production') {\n                if ((url.pathname === captureUrl.pathname) &&\n                    (url.origin !== captureUrl.origin)) {\n                    logger.debug(`${capture} only partially matches the cross-origin URL ` +\n                        `${url}. This route will only handle cross-origin requests ` +\n                        `if they match the entire URL.`);\n                }\n            }\n            return url.href === captureUrl.href;\n        };\n        // If `capture` is a string then `handler` and `method` must be present.\n        route = new Route(matchCallback, handler, method);\n    }\n    else if (capture instanceof RegExp) {\n        // If `capture` is a `RegExp` then `handler` and `method` must be present.\n        route = new RegExpRoute(capture, handler, method);\n    }\n    else if (typeof capture === 'function') {\n        // If `capture` is a function then `handler` and `method` must be present.\n        route = new Route(capture, handler, method);\n    }\n    else if (capture instanceof Route) {\n        route = capture;\n    }\n    else {\n        throw new WorkboxError('unsupported-route-type', {\n            moduleName: 'workbox-routing',\n            funcName: 'registerRoute',\n            paramName: 'capture',\n        });\n    }\n    const defaultRouter = getOrCreateDefaultRouter();\n    defaultRouter.registerRoute(route);\n    return route;\n};\n","/**\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nexport const cacheName = 'media';\nexport const channelName = 'messages';\nexport const fadeConfig = {duration: 200};\nexport const urlPrefix = '/_media/';\n","/**\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nimport {cacheName} from './constants';\n\nasync function _getCachedMediaMetadata() {\n  const cache = await caches.open(cacheName);\n  const requests = await cache.keys();\n  return Promise.all(requests.reverse().map(async (request) => {\n    const response = await cache.match(request);\n    return {\n      contentType: response.headers.get('content-type'),\n      src: request.url,\n    };\n  }));\n}\nconst cachedMediaMetadataPromise = _getCachedMediaMetadata();\n\nexport async function getCachedMediaMetadata(contentTypePrefix) {\n  const cachedMetadata = await cachedMediaMetadataPromise;\n  return cachedMetadata.filter((metadata) =>  metadata.contentType.startsWith(contentTypePrefix));\n}\n\n","<!--\nCopyright 2019 Google, Inc.\n\nLicensed under the [Apache License, Version 2.0](LICENSE) (the \"License\");\nyou may not use this file except in compliance with the License. You may\nobtain a copy of the License at\n\n  http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n<script context=\"module\">\n  export const href = '/audio';\n  export const mimePrefix = 'audio/';\n  export const mimeRoute = {href, mimePrefix};\n\texport const svg = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\"><path d=\"M0 0h24v24H0z\" fill=\"none\"/><path d=\"M12 3v9.28c-.47-.17-.97-.28-1.5-.28C8.01 12 6 14.01 6 16.5S8.01 21 10.5 21c2.31 0 4.2-1.75 4.45-4H15V6h4V3h-7z\"/></svg>';\n  export const text = 'Audio';\n\texport const title = 'Listen to saved audio.';\n</script>\n\n<script>\n  import {fade} from 'svelte/transition';\n\n  import {fadeConfig} from '../../js/constants';\n\timport {getCachedMediaMetadata} from '../../js/getCachedMediaMetadata';\n  import MediaList from '../components/MediaList.svelte';\n\n  const cachedMediaMetadataPromise = getCachedMediaMetadata(mimePrefix);\n</script>\n\n<div in:fade={fadeConfig}>\n  {#await cachedMediaMetadataPromise then cachedMediaMetadatas}\n    <MediaList {cachedMediaMetadatas} typeOfMedia={text.toLowerCase()}/>\n  {/await}\n</div>\n","<!--\nCopyright 2019 Google, Inc.\n\nLicensed under the [Apache License, Version 2.0](LICENSE) (the \"License\");\nyou may not use this file except in compliance with the License. You may\nobtain a copy of the License at\n\n  http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n<script context=\"module\">\n  export const href = '/images';\n  export const mimePrefix = 'image/';\n  export const mimeRoute = {href, mimePrefix};\n\texport const svg = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\"><path d=\"M0 0h24v24H0z\" fill=\"none\"/><path d=\"M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z\"/></svg>';\n  export const text = 'Images';\n\texport const title = 'View saved images.';\n</script>\n\n<script>\n  import {fade} from 'svelte/transition';\n\n  import {fadeConfig} from '../../js/constants';\n\timport {getCachedMediaMetadata} from '../../js/getCachedMediaMetadata';\n  import MediaList from '../components/MediaList.svelte';\n\n  const cachedMediaMetadataPromise = getCachedMediaMetadata(mimePrefix);\n</script>\n\n<div in:fade={fadeConfig}>\n  {#await cachedMediaMetadataPromise then cachedMediaMetadatas}\n    <MediaList {cachedMediaMetadatas} typeOfMedia={text.toLowerCase()}/>\n  {/await}\n</div>\n","<!--\nCopyright 2019 Google, Inc.\n\nLicensed under the [Apache License, Version 2.0](LICENSE) (the \"License\");\nyou may not use this file except in compliance with the License. You may\nobtain a copy of the License at\n\n  http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n<script context=\"module\">\n  export const href = '/videos';\n  export const mimePrefix = 'video/';\n  export const mimeRoute = {href, mimePrefix};\n\texport const svg = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\"><path d=\"M0 0h24v24H0z\" fill=\"none\"/><path d=\"M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4z\"/></svg>';\n  export const text = 'Videos';\n\texport const title = 'View saved videos.';\n</script>\n\n<script>\n  import {fade} from 'svelte/transition';\n\n  import {fadeConfig} from '../../js/constants';\n\timport {getCachedMediaMetadata} from '../../js/getCachedMediaMetadata';\n  import MediaList from '../components/MediaList.svelte';\n\n  const cachedMediaMetadataPromise = getCachedMediaMetadata(mimePrefix);\n</script>\n\n<div in:fade={fadeConfig}>\n  {#await cachedMediaMetadataPromise then cachedMediaMetadatas}\n    <MediaList {cachedMediaMetadatas} typeOfMedia={text.toLowerCase()}/>\n  {/await}\n</div>\n\n","import {CacheOnly} from 'workbox-strategies';\nimport {clientsClaim, skipWaiting} from 'workbox-core';\nimport {precacheAndRoute} from 'workbox-precaching';\nimport {RangeRequestsPlugin} from 'workbox-range-requests';\nimport {registerRoute} from 'workbox-routing';\n\nimport {cacheName, channelName, urlPrefix} from './constants';\nimport {mimeRoute as audioRoute} from '../svelte/routes/Audio.svelte';\nimport {mimeRoute as imagesRoute} from '../svelte/routes/Images.svelte';\nimport {mimeRoute as videosRoute} from '../svelte/routes/Videos.svelte';\n\nconst broadcastChannel = BroadcastChannel ? new BroadcastChannel(channelName) : null;\n\nconst shareTargetHandler = async ({event}) => {\n  if (broadcastChannel) {\n    broadcastChannel.postMessage('Saving media locally...');\n  }\n\n  const formData = await event.request.formData();\n  const mediaFiles = formData.getAll('media');\n  const cache = await caches.open(cacheName);\n\n  for (const mediaFile of mediaFiles) {\n    // TODO: Instead of bailing, come up with a\n    // default name for each possible MIME type.\n    if (!mediaFile.name) {\n      if (broadcastChannel) {\n        broadcastChannel.postMessage('Sorry! No name found on incoming media.');\n      }\n      continue;\n    }\n    await cache.put(\n      // TODO: Handle scenarios in which mediaFile.name isn't set,\n      // or doesn't include a proper extension.\n      `${urlPrefix}${Date.now()}-${mediaFile.name}`,\n      new Response(mediaFile, {\n        headers: {\n          'content-length': mediaFile.size,\n          'content-type': mediaFile.type,\n        },\n      })\n    );\n  }\n\n  // Use the MIME type of the first file shared to determine where we redirect.\n  const routeToRedirectTo = [\n    audioRoute,\n    imagesRoute,\n    videosRoute,\n  ].find((route) => mediaFiles[0].type.startsWith(route.mimePrefix));\n\n  const redirectionUrl = routeToRedirectTo ? `/#${routeToRedirectTo.href}` : '/';\n  \n  // After the POST succeeds, redirect to the main page.\n  return Response.redirect(redirectionUrl, 303);\n};\n\nconst cachedMediaHandler = new CacheOnly({\n  cacheName,\n  plugins: [\n    // Support for cache requests that include a Range: header.\n    new RangeRequestsPlugin(),\n  ],\n});\n\nskipWaiting();\nclientsClaim();\n\n// This will be replaced by the list of files to precache by\n// the `workbox injectManifest` build step.\nprecacheAndRoute(self.__WB_MANIFEST);\n\nregisterRoute(\n  '/_share-target',\n  shareTargetHandler,\n  'POST'\n);\n\nregisterRoute(\n  new RegExp(urlPrefix),\n  cachedMediaHandler\n);\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { cacheWrapper } from 'workbox-core/_private/cacheWrapper.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { messages } from './utils/messages.js';\nimport './_version.js';\n/**\n * An implementation of a\n * [cache-only]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-only}\n * request strategy.\n *\n * This class is useful if you want to take advantage of any\n * [Workbox plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}.\n *\n * If there is no cache match, this will throw a `WorkboxError` exception.\n *\n * @memberof workbox.strategies\n */\nclass CacheOnly {\n    /**\n     * @param {Object} options\n     * @param {string} options.cacheName Cache name to store and retrieve\n     * requests. Defaults to cache names provided by\n     * [workbox-core]{@link workbox.core.cacheNames}.\n     * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n     */\n    constructor(options = {}) {\n        this._cacheName = cacheNames.getRuntimeName(options.cacheName);\n        this._plugins = options.plugins || [];\n        this._matchOptions = options.matchOptions;\n    }\n    /**\n     * This method will perform a request strategy and follows an API that\n     * will work with the\n     * [Workbox Router]{@link workbox.routing.Router}.\n     *\n     * @param {Object} options\n     * @param {Request} options.request The request to run this strategy for.\n     * @param {Event} [options.event] The event that triggered the request.\n     * @return {Promise<Response>}\n     */\n    async handle({ event, request }) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-strategies',\n                className: 'CacheOnly',\n                funcName: 'makeRequest',\n                paramName: 'request',\n            });\n        }\n        const response = await cacheWrapper.match({\n            cacheName: this._cacheName,\n            request,\n            event,\n            matchOptions: this._matchOptions,\n            plugins: this._plugins,\n        });\n        if (process.env.NODE_ENV !== 'production') {\n            logger.groupCollapsed(messages.strategyStart('CacheOnly', request));\n            if (response) {\n                logger.log(`Found a cached response in the '${this._cacheName}'` +\n                    ` cache.`);\n                messages.printFinalResponse(response);\n            }\n            else {\n                logger.log(`No response found in the '${this._cacheName}' cache.`);\n            }\n            logger.groupEnd();\n        }\n        if (!response) {\n            throw new WorkboxError('no-response', { url: request.url });\n        }\n        return response;\n    }\n}\nexport { CacheOnly };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { createPartialResponse } from './createPartialResponse.js';\nimport './_version.js';\n/**\n * The range request plugin makes it easy for a request with a 'Range' header to\n * be fulfilled by a cached response.\n *\n * It does this by intercepting the `cachedResponseWillBeUsed` plugin callback\n * and returning the appropriate subset of the cached response body.\n *\n * @memberof workbox.rangeRequests\n */\nclass RangeRequestsPlugin {\n    constructor() {\n        /**\n         * @param {Object} options\n         * @param {Request} options.request The original request, which may or may not\n         * contain a Range: header.\n         * @param {Response} options.cachedResponse The complete cached response.\n         * @return {Promise<Response>} If request contains a 'Range' header, then a\n         * new response with status 206 whose body is a subset of `cachedResponse` is\n         * returned. Otherwise, `cachedResponse` is returned as-is.\n         *\n         * @private\n         */\n        this.cachedResponseWillBeUsed = async ({ request, cachedResponse }) => {\n            // Only return a sliced response if there's something valid in the cache,\n            // and there's a Range: header in the request.\n            if (cachedResponse && request.headers.has('range')) {\n                return await createPartialResponse(request, cachedResponse);\n            }\n            // If there was no Range: header, or if cachedResponse wasn't valid, just\n            // pass it through as-is.\n            return cachedResponse;\n        };\n    }\n}\nexport { RangeRequestsPlugin };\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { addRoute } from './addRoute.js';\nimport { precache } from './precache.js';\nimport './_version.js';\n/**\n * This method will add entries to the precache list and add a route to\n * respond to fetch events.\n *\n * This is a convenience method that will call\n * [precache()]{@link module:workbox-precaching.precache} and\n * [addRoute()]{@link module:workbox-precaching.addRoute} in a single call.\n *\n * @param {Array<Object|string>} entries Array of entries to precache.\n * @param {Object} [options] See\n * [addRoute() options]{@link module:workbox-precaching.addRoute}.\n *\n * @alias workbox.precaching.precacheAndRoute\n */\nexport const precacheAndRoute = (entries, options) => {\n    precache(entries);\n    addRoute(options);\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport './_version.js';\n/**\n * Force a service worker to become active, instead of waiting. This is\n * normally used in conjunction with `clientsClaim()`.\n *\n * @alias workbox.core.skipWaiting\n */\nexport const skipWaiting = () => {\n    // We need to explicitly call `self.skipWaiting()` here because we're\n    // shadowing `skipWaiting` with this local function.\n    addEventListener('install', () => self.skipWaiting());\n};\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport './_version.js';\n/**\n * Claim any currently available clients once the service worker\n * becomes active. This is normally used in conjunction with `skipWaiting()`.\n *\n * @alias workbox.core.clientsClaim\n */\nexport const clientsClaim = () => {\n    addEventListener('activate', () => self.clients.claim());\n};\n"],"names":["self","_","e","messageGenerator","code","args","msg","length","JSON","stringify","WorkboxError","Error","[object Object]","errorCode","details","super","this","name","_cacheNameDetails","googleAnalytics","precache","prefix","runtime","suffix","registration","scope","_createCacheName","cacheName","filter","value","join","cacheNames","updateDetails","fn","key","Object","keys","eachCacheNameDetail","getGoogleAnalyticsName","userCacheName","getPrecacheName","getPrefix","getRuntimeName","getSuffix","getFriendlyURL","url","urlObj","URL","String","location","href","origin","pathname","quotaErrorCallbacks","Set","pluginUtils","plugins","callbackName","plugin","matchWrapper","async","request","event","matchOptions","cache","caches","open","effectiveRequest","_getEffectiveRequest","mode","cachedResponse","match","pluginMethod","call","_isResponseSafeToCache","response","responseToCache","pluginsUsed","status","undefined","cacheKeyWillBeUsedPlugins","Request","cacheWrapper","put","updatePlugins","oldResponse","error","callback","executeQuotaErrorCallbacks","newResponse","fetchWrapper","fetch","fetchOptions","FetchEvent","preloadResponse","possiblePreloadResponse","failedFetchPlugins","originalRequest","clone","requestClone","err","thrownError","pluginFilteredRequest","fetchResponse","supportStatus","DBWrapper","version","onupgradeneeded","onversionchange","_db","_name","_version","_onupgradeneeded","_onversionchange","close","db","Promise","resolve","reject","openRequestTimedOut","setTimeout","OPEN_TIMEOUT","openRequest","indexedDB","onerror","evt","transaction","abort","result","onsuccess","bind","storeName","query","getAllKeys","count","getAllMatching","includeKeys","map","entry","index","direction","txn","done","store","objectStore","target","results","openCursor","cursor","push","continue","storeNames","type","onabort","oncomplete","method","objStore","apply","prototype","methodsToWrap","readonly","readwrite","methods","entries","IDBObjectStore","_call","copyResponse","modifier","clonedResponse","responseInit","headers","Headers","statusText","modifiedResponseInit","body","testResponse","Response","canConstructResponseFromBodyStream","blob","precachePlugins","get","newPlugins","REVISION_SEARCH_PARAM","createCacheKey","urlObject","cacheKey","revision","cacheKeyURL","originalURL","searchParams","set","PrecacheController","_cacheName","_urlsToCacheKeys","Map","_cacheKeysToIntegrities","has","firstEntry","secondEntry","integrity","toBePrecached","alreadyPrecached","alreadyCachedRequests","existingCacheKeys","precacheRequests","_addURLToCache","all","updatedURLs","item","notUpdatedURLs","currentlyCachedRequests","expectedCacheKeys","values","deletedURLs","delete","credentials","cacheWillUpdatePlugin","cacheWillUpdate","redirected","ignoreSearch","getCacheKeyForURL","precacheController","getOrCreatePrecacheController","options","urlsToCacheKeys","getURLsToCacheKeys","possibleURL","ignoreURLParametersMatching","directoryIndex","cleanURLs","urlManipulation","hash","urlWithoutIgnoredParams","paramName","some","regExp","test","removeIgnoredSearchParams","endsWith","directoryURL","cleanURL","additionalURLs","urlToAttempt","generateURLVariations","possibleCacheKey","listenerAdded","addRoute","addEventListener","precachedURL","responsePromise","then","respondWith","addFetchListener","installListener","waitUntil","install","catch","activateListener","activate","createPartialResponse","originalResponse","rangeHeader","boundaries","normalizedRangeHeader","trim","toLowerCase","startsWith","includes","rangeParts","exec","start","Number","end","parseRangeHeader","originalBlob","effectiveBoundaries","blobSize","size","effectiveStart","effectiveEnd","calculateEffectiveBoundaries","slicedBlob","slice","slicedBlobSize","slicedResponse","defaultMethod","normalizeHandler","handler","handle","Route","RegExpRoute","Router","_routes","routes","handleRequest","data","payload","requestPromises","urlsToCache","ports","postMessage","protocol","params","route","findMatchingRoute","_defaultHandler","_catchHandler","matchResult","Array","isArray","constructor","routeIndex","indexOf","splice","defaultRouter","getOrCreateDefaultRouter","addCacheListener","registerRoute","capture","captureUrl","RegExp","moduleName","funcName","requests","reverse","contentType","src","_getCachedMediaMetadata","mimeRoute","mimePrefix","broadcastChannel","BroadcastChannel","cachedMediaHandler","_plugins","_matchOptions","cachedResponseWillBeUsed","skipWaiting","clients","claim","addToCacheList","__WB_MANIFEST","mediaFiles","formData","getAll","mediaFile","Date","now","content-length","content-type","routeToRedirectTo","audioRoute","imagesRoute","videosRoute","find","redirectionUrl","redirect"],"mappings":"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"}
